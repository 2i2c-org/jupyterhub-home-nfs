#!/usr/bin/env python3
"""
Maintain user home directory quotas on XFS.

Many JupyterHubs use NFS for home directories. While kubernetes
offers memory & CPU isolation, disk quotas for NFS is hard to come
by. No hosted NFS service (EFS, Filestore, etc) offer quotas, and
most common file systems only offer per-userid quotas. XFS offers
'project' quotas, which are checked against any given directory. That
is what we want for our hubs!

This script can be run as a daemon in a machine acting as an
NFS server, setting up quotas with XFS as each home directory appears.
There can be a few seconds lag between the time the home directory appears
and the quota is set, but that should be ok for now (we can fix that with
inotify if we need to).

Your home directories must already be on an XFS file system, with prjquota
mount option enabled.

The script runs two reconciliation loops:

1. Entries in /etc/projects & /etc/projid (or equivalent) for all home directories in the
   given paths
2. Correct xfs_quota project & limit setup for each entry in /etc/projid

This is run in a loop, and should provide fairly robust quotaing setup.

This script *owns* /etc/projects and /etc/projid (or equivalent). If there are entries
there that aren't put in there by this script, they will be removed!
"""

import contextlib
import itertools
import logging
import os
import os.path
import subprocess
import sys
import tempfile
import time

from prometheus_client import start_http_server
from traitlets import Bool, Dict, Float, Int, List, Unicode
from traitlets.config import Application

from . import metrics

# Line at beginning of projid / projects file stating ownership
OWNERSHIP_PREAMBLE = (
    "# This file is generated by jupyterhub-home-nfs. Do not modify by hand\n"
)


@contextlib.contextmanager
def open_replace_atomic(path, *, mode="w"):
    """Open a temporary file in the same directory as `path`. Upon leaving the context,
    use atomic `os.replace` to move the file to the proper destination, enabling
    atomic writing."""
    path_dir, name = os.path.split(path)
    temp_fd, temp_path = tempfile.mkstemp(dir=path_dir, prefix=name)
    with open(temp_path, mode) as f:
        yield f
    os.replace(temp_path, path)


def logged_check_call(
    args,
    logger,
    *,
    log_stdout=True,
    log_stderr=True,
):
    """
    Run `subprocess.check_call` with a logger to output stdio.
    Return the stdout of the stream.
    """
    # Only record stderr if asked
    stderr_kind = subprocess.PIPE if log_stderr else subprocess.DEVNULL
    result = subprocess.run(
        args,
        stdout=subprocess.PIPE,
        stderr=stderr_kind,
        encoding="utf8",
        errors="surrogateescape",
    )

    # Set log level according to return code
    log_level = logging.ERROR if result.returncode else logging.DEBUG

    # Handle stdout
    if log_stdout:
        for line in result.stdout.splitlines():
            logger.log(log_level, line)

    # Handle stderr
    if log_stderr:
        for line in result.stderr.splitlines():
            logger.log(log_level, line)

    result.check_returncode()
    return result.stdout


def parse_projids(path):
    """
    Parse a projids file, returning mapping of paths to project IDs
    """
    projects = {}
    if os.path.exists(path):
        with open(path) as f:
            for line in f:
                if line.strip().startswith("#"):
                    continue
                splits = line.split(":", 2)
                projects[splits[0]] = int(splits[1])
    return projects


class QuotaManager(Application):
    # Config file can be loaded from this location
    config_file = Unicode("", help="The config file to load").tag(config=True)

    # Define all configuration parameters as traitlets
    paths = List(
        Unicode(), default_value=[], help="Paths to scan for home directories"
    ).tag(config=True)

    projects_file = Unicode(
        default_value="/etc/projects", help="Path to projects file"
    ).tag(config=True)

    projid_file = Unicode(default_value="/etc/projid", help="Path to projid file").tag(
        config=True
    )

    min_projid = Int(
        default_value=1000,
        help="Project IDs will be generated starting from this number",
    ).tag(config=True)

    wait_time = Int(
        default_value=30, help="Number of seconds to wait between runs"
    ).tag(config=True)

    hard_quota = Float(
        default_value=10.0,
        help="Hard quota limit (in GiB) to set for all home directories",
    ).tag(config=True)

    exclude = List(
        Unicode(),
        default_value=[],
        help="List of directory names to exclude setting quotas on",
    ).tag(config=True)

    quota_overrides = Dict(
        value_trait=Float(),
        default_value={},
        help="Dictionary mapping directory names to custom quota limits (in GiB)",
    ).tag(config=True)

    uid = Int(
        default_value=1000,
        help="The UID that will own the home directories and initial share",
    ).tag(config=True)

    gid = Int(
        default_value=1000,
        help="The GID that will own the home directories and initial share",
    ).tag(config=True)

    metrics_port = Int(default_value=7500, help="Port to expose prometheus metrics on")

    enable_metrics = Bool(default_value=True, help="Enable prometheus metrics")

    aliases = {
        "config-file": "QuotaManager.config_file",
        "paths": "QuotaManager.paths",
        "projects-file": "QuotaManager.projects_file",
        "projid-file": "QuotaManager.projid_file",
        "min-projid": "QuotaManager.min_projid",
        "wait-time": "QuotaManager.wait_time",
        "hard-quota": "QuotaManager.hard_quota",
        "exclude": "QuotaManager.exclude",
        "quota-overrides": "QuotaManager.quota_overrides",
        "uid": "QuotaManager.uid",
        "gid": "QuotaManager.gid",
    }

    def initialize(self, argv=None):
        self.parse_command_line(argv)
        if self.config_file:
            self.load_config_file(self.config_file)
        self.load_config_environ()
        if not self.paths:
            self.log.error("No paths specified!")
            sys.exit(1)

    def mountpoint_for(self, path):
        """
        Return mount point containing file / directory in path

        xfs_quota wants to know which fs to operate on
        """
        result = logged_check_call(
            ["df", "--output=target", os.fspath(path)], self.log, log_stdout=False
        )
        return result.strip().splitlines()[-1].strip()

    def reconcile_projfiles(self, *, is_dirty=False):
        """
        Make sure each homedir in paths has an appropriate projid entry.

        This 'owns' /etc/projects & /etc/projid (or equivalent) as well. If there are extra entries there,
        they will be removed!
        """
        # Fetch existing home directories
        # Sort to provide consistent ordering across runs
        homedirs = []
        for path in self.paths:
            # Create the directory if it doesn't exist and make sure is owned by uid:gid
            os.makedirs(path, exist_ok=True)
            os.chown(path, self.uid, self.gid)
            for ent in os.scandir(path):
                if ent.is_dir():
                    homedirs.append(ent.path)

        homedirs.sort()
        self.log.debug(f"homedirs: {homedirs}")

        if is_dirty:
            projects = {}
            self.log.debug("Ignoring existing projects")
        else:
            # Fetch list of projects in /etc/projid file, assumed to sync'd to /etc/projects file
            projects = parse_projids(self.projid_file)

        self.log.debug(f"projects: {projects}")

        # We have to write /etc/projid & /etc/projects if they aren't completely in sync
        projid_file_dirty = sorted(list(projects.keys())) != sorted(homedirs)

        if projid_file_dirty:
            # Make sure /etc/projid & /etc/projects are in sync with home dirs
            for home in homedirs:
                if home in projects:
                    continue
                # Ensure an entry exists in projects
                projects[home] = max(projects.values() or [self.min_projid]) + 1
                self.log.debug(f"Found new project {home}")

            # Remove projects that don't have corresponding homedirs
            projects = {k: v for k, v in projects.items() if k in homedirs}

            with (
                open_replace_atomic(self.projects_file) as projects_file,
                open_replace_atomic(self.projid_file) as projid_file,
            ):
                projects_file.write(OWNERSHIP_PREAMBLE)
                projid_file.write(OWNERSHIP_PREAMBLE)
                for path, id in projects.items():
                    projid_file.write(f"{path}:{id}\n")
                    projects_file.write(f"{id}:{path}\n")

            self.log.debug(
                f"Writing projid to {self.projid_file} and projects to {self.projects_file}"
            )

        # Finally, ensure we actually have these files
        elif not (
            os.path.exists(self.projects_file) or os.path.exists(self.projid_file)
        ):
            with (
                open_replace_atomic(self.projects_file) as projects_file,
                open_replace_atomic(self.projid_file) as projid_file,
            ):
                projects_file.write(OWNERSHIP_PREAMBLE)
                projid_file.write(OWNERSHIP_PREAMBLE)

    def get_applied_projects(self):
        """
        Determine existing applied project IDs
        """
        try:
            result = logged_check_call(
                ["lsattr", "-p", *self.paths],
                self.log,
                log_stdout=False,
            )
        except subprocess.CalledProcessError as e:
            self.log.error(
                f"Checking project metadata for paths {self.paths} failed! Continuing...",
                exc_info=e,
            )

            return {}

        return {
            path: int(projid)
            for projid, _, path in (
                line.split() for line in result.strip().splitlines()
            )
        }
        return

    def get_applied_quotas(self):
        """
        Determine existing applied quotas
        """
        result = logged_check_call(
            [
                "xfs_quota",
                "-x",
                "-c",
                "report -N -p -bir",
                "-D",
                f"{self.projects_file}",
                "-P",
                f"{self.projid_file}",
            ],
            self.log,
            log_stdout=False,
        )

        # Parse a collection of quotas (e.g. blocks, inodes)
        def parse_collection(quotas):
            used, soft, hard, warn, grace = itertools.islice(quotas, 5)
            return {"soft": int(soft), "hard": int(hard), "used": int(used)}

        quotas = {}
        for line in result.strip().splitlines():
            items = iter(line.split())
            path = next(items)
            blocks = parse_collection(items)
            inodes = parse_collection(items)
            realtime = parse_collection(items)
            # Everything here is in kb, since that's what xfs_quota reports things in
            quotas[path] = {"blocks": blocks, "inodes": inodes, "realtime": realtime}

        return quotas

    def quota_is_dirty(self, quotas, intended_block_quota):
        """
        Determine whether the filesystem quota values are dirty with respect to intended quotas
        """
        if quotas["blocks"]["hard"] != intended_block_quota:
            return True

        # Have any other quotas changed?
        return any(
            quotas[group][kind]
            for group, kind in itertools.product(
                ("inodes", "realtime"), ("hard", "soft")
            )
        )

    def update_metrics(self, applied_quotas: dict[str, dict]):
        for directory_path, quotas in applied_quotas.items():
            # Let's determine directory name to not be the full path (as that's an implementation detail)
            # but just the specific path that's beyond the common base path.
            directory_name = None
            for path in self.paths:
                if directory_path.startswith(path):
                    # FIXME: Is there some sort of directory traversal attack possible here?
                    directory_name = directory_path[len(path) + 1 :]
                    break

            if directory_name is None:
                # This isn't managed by us
                continue
            # xfs_quotas sets things in KB, so let's convert it to bytes
            metrics.HARD_LIMIT.labels(directory=directory_name).set(
                quotas["blocks"]["hard"] * 1024
            )
            metrics.TOTAL_SIZE.labels(directory=directory_name).set(
                quotas["blocks"]["used"] * 1024
            )

    def reconcile_quotas(self, *, is_dirty=False):
        """
        Make sure each project in /etc/projid has correct hard quota set
        """
        # Convert GiB to KiB for xfs_quota
        hard_quota_kb = int(self.hard_quota * 1024 * 1024)
        # Convert quota_overrides from GiB to KiB
        quota_overrides_kb = {
            dirname: int(quota_gb * 1024 * 1024)
            for dirname, quota_gb in self.quota_overrides.items()
        }

        # Get current set of projects on disk
        projects = parse_projids(self.projid_file)

        # Fetch quota information from filesystem
        applied_quotas = self.get_applied_quotas()
        applied_projects = self.get_applied_projects()

        self.update_metrics(applied_quotas)

        self.log.debug(f"Applied quotas: {applied_quotas}")

        # Set quotas based on priority: quota_overrides > exclude_dirs > hard_quota_kb
        intended_quotas = {}
        for project in projects:
            dirname = os.path.basename(project)
            if dirname in quota_overrides_kb:
                # Override takes highest priority
                intended_quotas[project] = quota_overrides_kb[dirname]
            elif dirname in self.exclude:
                # Exclude means 0 quota
                intended_quotas[project] = 0
            else:
                # Default quota
                intended_quotas[project] = hard_quota_kb

        self.log.debug(f"Intended quotas: {intended_quotas}")

        # Allow quotas to be forcibly treated as dirty
        if is_dirty:
            changed_projects = [*projects]
        else:
            # Check for projects that don't have a correct quota
            changed_projects = [
                p
                for p, projid in projects.items()
                # Check project ID mapping is valid
                if applied_projects.get(p) != projid
                # Check quotas are valid
                or p not in applied_quotas
                or self.quota_is_dirty(applied_quotas[p], intended_quotas[p])
            ]

        # Adjust quotas for projects that don't the correct quota set
        if not changed_projects:
            return

        for project in changed_projects:
            mountpoint = self.mountpoint_for(project)
            self.log.info(f"Setting up xfs_quota project for {project}")
            try:
                logged_check_call(
                    [
                        "xfs_quota",
                        "-x",
                        "-c",
                        f"project -s {project}",
                        "-D",
                        f"{self.projects_file}",
                        "-P",
                        f"{self.projid_file}",
                        mountpoint,
                    ],
                    self.log,
                    # stderr can be huge for this call, because it includes verbose per-file information
                    # let's exclude it to avoid OOM errors with large amounts of string processing'
                    log_stderr=False,
                )
            except subprocess.CalledProcessError as e:
                self.log.error(
                    f"Setting up project for {project} failed! Continuing...",
                    exc_info=e,
                )
                continue

            self.log.info(
                f"Setting limit for project {project} to {intended_quotas[project]}k"
            )
            try:
                logged_check_call(
                    [
                        "xfs_quota",
                        "-x",
                        "-c",
                        f"limit -p bhard={intended_quotas[project]}k bsoft=0 ihard=0 isoft=0 rtbsoft=0 rtbhard=0 {project}",
                        "-D",
                        f"{self.projects_file}",
                        "-P",
                        f"{self.projid_file}",
                        mountpoint,
                    ],
                    self.log,
                )
            except subprocess.CalledProcessError as e:
                self.log.error(
                    f"Setting up limit for {project} failed! Continuing...",
                    exc_info=e,
                )
                continue

    def reconcile_step(self, *, projfiles_is_dirty=False, quotas_is_dirty=False):
        self.reconcile_projfiles(is_dirty=projfiles_is_dirty)
        self.reconcile_quotas(is_dirty=quotas_is_dirty)

    def start(self):
        if self.enable_metrics:
            metrics_server, metrics_server_thread = start_http_server(self.metrics_port)
        try:
            while True:
                self.reconcile_step()
                time.sleep(self.wait_time)
        finally:
            if self.enable_metrics:
                metrics_server.shutdown()
                metrics_server_thread.join()


def main():
    QuotaManager.launch_instance()


if __name__ == "__main__":
    main()
