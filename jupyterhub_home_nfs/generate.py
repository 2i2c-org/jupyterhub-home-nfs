#!/usr/bin/env python3
"""
Maintain user home directory quotas on XFS.

Many JupyterHubs use NFS for home directories. While kubernetes
offers memory & CPU isolation, disk quotas for NFS is hard to come
by. No hosted NFS service (EFS, Filestore, etc) offer quotas, and
most common file systems only offer per-userid quotas. XFS offers
'project' quotas, which are checked against any given directory. That
is what we want for our hubs!

This script can be run as a daemon in a machine acting as an
NFS server, setting up quotas with XFS as each home directory appears.
There can be a few seconds lag between the time the home directory appears
and the quota is set, but that should be ok for now (we can fix that with
inotify if we need to).

Your home directories must already be on an XFS file system, with prjquota
mount option enabled.

The script runs two reconciliation loops:

1. Entries in /etc/projects & /etc/projid (or equivalent) for all home directories in the
   given paths
2. Correct xfs_quota project & limit setup for each entry in /etc/projid

This is run in a loop, and should provide fairly robust quotaing setup.

This script *owns* /etc/projects and /etc/projid (or equivalent). If there are entries
there that aren't put in there by this script, they will be removed!
"""

import contextlib
import logging
import os
import os.path
import subprocess
import sys
import tempfile
import time

from traitlets import Dict, Float, Int, List, Unicode
from traitlets.config import Application

# Line at beginning of projid / projects file stating ownership
OWNERSHIP_PREAMBLE = (
    "# This file is generated by jupyterhub-home-nfs. Do not modify by hand\n"
)


@contextlib.contextmanager
def open_replace_atomic(path, *, mode="w"):
    """Open a temporary file in the same directory as `path`. Upon leaving the context,
    use atomic `os.replace` to move the file to the proper destination, enabling
    atomic writing."""
    path_dir, name = os.path.split(path)
    temp_fd, temp_path = tempfile.mkstemp(dir=path_dir, prefix=name)
    with open(temp_path, mode) as f:
        yield f
    os.replace(temp_path, path)


def logged_check_call(args, logger, *, log_stdout=True, log_stderr=True):
    """
    Run `subprocess.check_call` with a logger to output stdio.
    """
    result = subprocess.run(args, capture_output=True)
    log_level = logging.ERROR if result.returncode else logging.DEBUG

    if log_stdout:
        for line in result.stdout.decode().splitlines():
            logger.log(log_level, line)

    if log_stderr:
        for line in result.stderr.decode().splitlines():
            logger.log(log_level, line)

    result.check_returncode()
    return result


def parse_projids(path):
    """
    Parse a projids file, returning mapping of paths to project IDs
    """
    projects = {}
    if os.path.exists(path):
        with open(path) as f:
            for line in f:
                if line.strip().startswith("#"):
                    continue
                splits = line.split(":", 2)
                projects[splits[0]] = int(splits[1])
    return projects


class QuotaManager(Application):
    # Config file can be loaded from this location
    config_file = Unicode("", help="The config file to load").tag(config=True)

    # Define all configuration parameters as traitlets
    paths = List(
        Unicode(), default_value=[], help="Paths to scan for home directories"
    ).tag(config=True)

    projects_file = Unicode(
        default_value="/etc/projects", help="Path to projects file"
    ).tag(config=True)

    projid_file = Unicode(default_value="/etc/projid", help="Path to projid file").tag(
        config=True
    )

    min_projid = Int(
        default_value=1000,
        help="Project IDs will be generated starting from this number",
    ).tag(config=True)

    wait_time = Int(
        default_value=30, help="Number of seconds to wait between runs"
    ).tag(config=True)

    hard_quota = Float(
        default_value=10.0,
        help="Hard quota limit (in GB) to set for all home directories",
    ).tag(config=True)

    exclude = List(
        Unicode(),
        default_value=[],
        help="List of directory names to exclude setting quotas on",
    ).tag(config=True)

    quota_overrides = Dict(
        value_trait=Float(),
        default_value={},
        help="Dictionary mapping directory names to custom quota limits (in GB)",
    ).tag(config=True)

    aliases = {
        "config-file": "QuotaManager.config_file",
        "paths": "QuotaManager.paths",
        "projects-file": "QuotaManager.projects_file",
        "projid-file": "QuotaManager.projid_file",
        "min-projid": "QuotaManager.min_projid",
        "wait-time": "QuotaManager.wait_time",
        "hard-quota": "QuotaManager.hard_quota",
        "exclude": "QuotaManager.exclude",
        "quota-overrides": "QuotaManager.quota_overrides",
    }

    def initialize(self, argv=None):
        self.parse_command_line(argv)
        if self.config_file:
            self.load_config_file(self.config_file)
        self.load_config_environ()
        if not self.paths:
            self.log.error("No paths specified!")
            sys.exit(1)

    def mountpoint_for(self, path):
        """
        Return mount point containing file / directory in path

        xfs_quota wants to know which fs to operate on
        """
        result = logged_check_call(
            ["df", "--output=target", os.fspath(path)], self.log, log_stdout=False
        )
        return result.stdout.decode().strip().splitlines()[-1].strip()

    def get_quotas(self):
        result = logged_check_call(
            [
                "xfs_quota",
                "-x",
                "-c",
                "report -N -p",
                "-D",
                f"{self.projects_file}",
                "-P",
                f"{self.projid_file}",
            ],
            self.log,
            log_stdout=False,
        )

        quotas = {}
        for line in result.stdout.decode().strip().splitlines():
            path, used, soft, hard, warn, grace = line.split()
            # Everything here is in kb, since that's what xfs_quota reports things in
            quotas[path] = {
                "used": int(used),
                "soft": int(soft),
                "hard": int(hard),
                "warn": int(warn),
                "grace": grace,
            }
        return quotas

    def reconcile_projfiles(self):
        """
        Make sure each homedir in paths has an appropriate projid entry.

        This 'owns' /etc/projects & /etc/projid (or equivalent) as well. If there are extra entries there,
        they will be removed!
        """
        # Fetch existing home directories
        # Sort to provide consistent ordering across runs
        homedirs = []
        for path in self.paths:
            # Create the directory if it doesn't exist
            os.makedirs(path, exist_ok=True)
            for ent in os.scandir(path):
                if ent.is_dir():
                    homedirs.append(ent.path)

        homedirs.sort()
        self.log.debug(f"homedirs: {homedirs}")

        # Fetch list of projects in /etc/projid file, assumed to sync'd to /etc/projects file
        projects = parse_projids(self.projid_file)
        self.log.debug(f"projects: {projects}")

        # We have to write /etc/projid & /etc/projects if they aren't completely in sync
        projid_file_dirty = sorted(list(projects.keys())) != sorted(homedirs)

        if projid_file_dirty:
            # Check if there are any homedirs that aren't in projects
            new_homes = [h for h in homedirs if h not in projects]

            # Make sure /etc/projid & /etc/projects are in sync with home dirs
            if new_homes:
                for home in new_homes:
                    # Ensure an entry exists in projects
                    if home not in projects:
                        projects[home] = max(projects.values() or [self.min_projid]) + 1
                        self.log.debug(f"Found new project {home}")

            # Remove projects that don't have corresponding homedirs
            projects = {k: v for k, v in projects.items() if k in homedirs}

            with (
                open_replace_atomic(self.projects_file) as projects_file,
                open_replace_atomic(self.projid_file) as projid_file,
            ):
                projects_file.write(OWNERSHIP_PREAMBLE)
                projid_file.write(OWNERSHIP_PREAMBLE)
                for path, id in projects.items():
                    projid_file.write(f"{path}:{id}\n")
                    projects_file.write(f"{id}:{path}\n")

            self.log.debug(
                f"Writing projid to {self.projid_file} and projects to {self.projects_file}"
            )

        # Finally, ensure we actually have these files
        elif not (
            os.path.exists(self.projects_file) or os.path.exists(self.projid_file)
        ):
            with (
                open_replace_atomic(self.projects_file) as projects_file,
                open_replace_atomic(self.projid_file) as projid_file,
            ):
                projects_file.write(OWNERSHIP_PREAMBLE)
                projid_file.write(OWNERSHIP_PREAMBLE)

    def reconcile_quotas(self, *, is_dirty=False):
        """
        Make sure each project in /etc/projid has correct hard quota set
        """
        # Convert GB to KB for xfs_quota
        hard_quota_kb = int(self.hard_quota * 1024 * 1024)
        # Convert quota_overrides from GB to KB
        quota_overrides_kb = {
            dirname: int(quota_gb * 1024 * 1024)
            for dirname, quota_gb in self.quota_overrides.items()
        }

        # Get current set of projects on disk
        projects = parse_projids(self.projid_file)
        # Fetch quota information from xfs_quota
        quotas = self.get_quotas()
        self.log.debug(f"Quotas: {quotas}")

        # Set quotas based on priority: quota_overrides > exclude_dirs > hard_quota_kb
        intended_quotas = {}
        for project in projects:
            dirname = os.path.basename(project)
            if dirname in quota_overrides_kb:
                # Override takes highest priority
                intended_quotas[project] = quota_overrides_kb[dirname]
            elif dirname in self.exclude:
                # Exclude means 0 quota
                intended_quotas[project] = 0
            else:
                # Default quota
                intended_quotas[project] = hard_quota_kb

        self.log.debug(f"Intended quotas: {intended_quotas}")

        # Check for projects that don't have any nor correct quota
        if is_dirty:
            changed_projects = [*projects]
        else:
            changed_projects = [
                p
                for p in projects
                if quotas.get(p, {}).get("hard") != intended_quotas[p]
            ]

        # Adjust quotas for projects that don't the correct quota set
        if not changed_projects:
            return

        for project in changed_projects:
            mountpoint = self.mountpoint_for(project)
            self.log.info(f"Setting up xfs_quota project for {project}")
            try:
                logged_check_call(
                    [
                        "xfs_quota",
                        "-x",
                        "-c",
                        f"project -s {project}",
                        "-D",
                        f"{self.projects_file}",
                        "-P",
                        f"{self.projid_file}",
                        mountpoint,
                    ],
                    self.log,
                )
            except subprocess.CalledProcessError as e:
                self.log.error(
                    f"Setting up project for {project} failed! Continuing...",
                    exc_info=e,
                )
                continue
            self.log.info(
                f"Setting limit for project {project} to {intended_quotas[project]}k"
            )
            try:
                logged_check_call(
                    [
                        "xfs_quota",
                        "-x",
                        "-c",
                        f"limit -p bhard={intended_quotas[project]}k {project}",
                        "-D",
                        f"{self.projects_file}",
                        "-P",
                        f"{self.projid_file}",
                        mountpoint,
                    ],
                    self.log,
                )
            except subprocess.CalledProcessError as e:
                self.log.error(
                    f"Setting up limit for {project} failed! Continuing...",
                    exc_info=e,
                )
                continue

    def clear_existing_quotas(self):
        for path in self.paths:
            mountpoint = self.mountpoint_for(path)
            # Create a new project with ID 1, and clear it
            try:
                logged_check_call(
                    [
                        "xfs_quota",
                        "-x",
                        "-c",
                        f"project -C -p {path} 1",
                        "-D",
                        "/dev/null",
                        "-P",
                        "/dev/null",
                        mountpoint,
                    ],
                    self.log,
                )
            except subprocess.CalledProcessError as e:
                self.log.error(
                    f"Clearing quotas for path {path} failed! Continuing...",
                    exc_info=e,
                )
                continue

    def reconcile_step(self, *, is_dirty=False):
        self.reconcile_projfiles()
        self.reconcile_quotas(is_dirty=is_dirty)

    def start(self):
        # Clear all inode quota information
        self.clear_existing_quotas()
        # Forcibly update inodes with proper quotas
        self.reconcile_step(is_dirty=True)
        while True:
            time.sleep(self.wait_time)
            self.reconcile_step()


def main():
    QuotaManager.launch_instance()


if __name__ == "__main__":
    main()
