#!/usr/bin/env python3
"""
Maintain user home directory quotas on XFS.

Many JupyterHubs use NFS for home directories. While kubernetes
offers memory & CPU isolation, disk quotas for NFS is hard to come
by. No hosted NFS service (EFS, Filestore, etc) offer quotas, and
most common file systems only offer per-userid quotas. XFS offers
'project' quotas, which are checked against any given directory. That
is what we want for our hubs!

This script can be run as a daemon in a machine acting as an
NFS server, setting up quotas with XFS as each home directory appears.
There can be a few seconds lag between the time the home directory appears
and the quota is set, but that should be ok for now (we can fix that with
inotify if we need to).

Your home directories must already be on an XFS file system, with prjquota
mount option enabled.

The script runs two reconciliation loops:

1. Entries in /etc/projects & /etc/projid for all home directories in the
   given paths
2. Correct xfs_quota project & limit setup for each entry in /etc/projid

This is run in a loop, and should provide fairly robust quotaing setup.

This script *owns* /etc/projects and /etc/projid. If there are entries
there that aren't put in there by this script, they will be removed!
"""
import sys
import os
import time
import subprocess

from traitlets.config import Application
from traitlets import List, Unicode, Int, Float

# Line at beginning of projid / projects file stating ownership
OWNERSHIP_PREAMBLE = (
    "# This file is generated by jupyterhub-home-nfs. Do not modify by hand\n"
)


def parse_projids(path):
    """
    Parse a projids file, returning mapping of paths to project IDs
    """
    projects = {}
    if os.path.exists(path):
        with open(path) as f:
            for line in f:
                if line.strip().startswith("#"):
                    continue
                splits = line.split(":", 2)
                projects[splits[0]] = int(splits[1])
    return projects


def mountpoint_for(path):
    """
    Return mount point containing file / directory in path

    xfs_quota wants to know which fs to operate on
    """
    return (
        subprocess.check_output(["df", "--output=target", path])
        .decode()
        .strip()
        .split("\n")[-1]
        .strip()
    )


def get_quotas():
    output = (
        subprocess.check_output(["xfs_quota", "-x", "-c", "report -N -p"])
        .decode()
        .strip()
    )
    quotas = {}
    for line in output.split("\n"):
        path, used, soft, hard, warn, grace = line.split()
        # Everything here is in kb, since that's what xfs_quota reports things in
        quotas[path] = {
            "used": int(used),
            "soft": int(soft),
            "hard": int(hard),
            "warn": int(warn),
            "grace": grace,
        }
    return quotas


def reconcile_projfiles(paths, projects_file_path, projid_file_path, min_projid):
    """
    Make sure each homedir in paths has an appropriate projid entry.

    This 'owns' /etc/projets & /etc/projid as well. If there are extra entries there,
    they will be removed!
    """
    # Fetch existing home directories
    # Sort to provide consistent ordering across runs
    homedirs = []
    for path in paths:
        for ent in os.scandir(path):
            if ent.is_dir():
                homedirs.append(ent.path)

    homedirs.sort()
    print(f"homedirs: {homedirs}")

    # Fetch list of projects in /etc/projid file, assumed to sync'd to /etc/projects file
    projects = parse_projids(projid_file_path)
    print(f"projects: {projects}")

    # We have to write /etc/projid & /etc/projects if they aren't completely in sync
    projid_file_dirty = sorted(list(projects.keys())) != sorted(homedirs)

    if projid_file_dirty:
        # Check if there are any homedirs that aren't in projects
        new_homes = [h for h in homedirs if h not in projects]

        # Make sure /etc/projid & /etc/projects are in sync with home dirs
        if new_homes:
            for home in new_homes:
                # Ensure an entry exists in projects
                if home not in projects:
                    projects[home] = max(projects.values() or [min_projid]) + 1
                    projid_file_dirty = True
                    print(f"Found new project {home}")

        # Remove projects that don't have corresponding homedirs
        projects = {k: v for k, v in projects.items() if k in homedirs}

        # FIXME: make this an atomic write
        with open(projects_file_path, "w") as projects_file, open(
            projid_file_path, "w"
        ) as projid_file:
            projects_file.write(OWNERSHIP_PREAMBLE)
            projid_file.write(OWNERSHIP_PREAMBLE)
            for path, id in projects.items():
                projid_file.write(f"{path}:{id}\n")
                projects_file.write(f"{id}:{path}\n")

        print(
            f"Writing projid to {projid_file_path} and projects to {projects_file_path}"
        )


def initialize_projects(projid_file_path):
    """
    Set up xfs_quota projects for all projects in /etc/projid
    """
    projects = parse_projids(projid_file_path)
    for project in projects:
        mountpoint = mountpoint_for(project)
        subprocess.check_call(
            ["xfs_quota", "-x", "-c", f"project -s {project}", mountpoint]
        )
        print(f"Setting up xfs_quota project for {project}")


def reconcile_quotas(projid_file_path, hard_quota_kb, exclude_dirs):
    """
    Make sure each project in /etc/projid has correct hard quota set
    """

    # Get current set of projects on disk
    projects = parse_projids(projid_file_path)
    # Fetch quota information from xfs_quota
    quotas = get_quotas()
    print(f"Quotas: {quotas}")

    # If exclude_dirs is provided, set quotas to 0 for those projects,
    # otherwise set the intended quota to hard_quota_kb
    intended_quotas = {
        project: (hard_quota_kb if os.path.basename(project) not in exclude_dirs else 0)
        for project in projects
    }

    print(f"Intended quotas: {intended_quotas}")

    # Check for projects that don't have any nor correct quota
    changed_projects = [
        p for p in projects if quotas.get(p, {}).get("hard") != intended_quotas[p]
    ]

    # Make sure xfs_quotas is in sync
    if changed_projects:
        for project in changed_projects:
            mountpoint = mountpoint_for(project)
            if project not in quotas:
                subprocess.check_call(
                    ["xfs_quota", "-x", "-c", f"project -s {project}", mountpoint]
                )
                print(f"Setting up xfs_quota project for {project}")
            if (
                project not in quotas
                or quotas[project]["hard"] != intended_quotas[project]
            ):
                subprocess.check_call(
                    [
                        "xfs_quota",
                        "-x",
                        "-c",
                        f"limit -p bhard={intended_quotas[project]}k {project}",
                        mountpoint,
                    ]
                )
                print(
                    f"Setting limit for project {project} to {intended_quotas[project]}k"
                )


class QuotaManager(Application):
    # Config file can be loaded from this location
    config_file = Unicode("", help="The config file to load").tag(config=True)

    # Define all configuration parameters as traitlets
    paths = List(
        Unicode(), default_value=[], help="Paths to scan for home directories"
    ).tag(config=True)

    projects_file = Unicode(
        default_value="/etc/projects", help="Path to projects file"
    ).tag(config=True)

    projid_file = Unicode(default_value="/etc/projid", help="Path to projid file").tag(
        config=True
    )

    min_projid = Int(
        default_value=1000,
        help="Project IDs will be generated starting from this number",
    ).tag(config=True)

    wait_time = Int(
        default_value=30, help="Number of seconds to wait between runs"
    ).tag(config=True)

    hard_quota = Float(
        default_value=10.0,
        help="Hard quota limit (in GB) to set for all home directories",
    ).tag(config=True)

    exclude = List(
        Unicode(),
        default_value=[],
        help="List of directory names to exclude setting quotas on",
    ).tag(config=True)

    aliases = {
        "config-file": "QuotaManager.config_file",
        "paths": "QuotaManager.paths",
        "projects-file": "QuotaManager.projects_file",
        "projid-file": "QuotaManager.projid_file",
        "min-projid": "QuotaManager.min_projid",
        "wait-time": "QuotaManager.wait_time",
        "hard-quota": "QuotaManager.hard_quota",
    }

    def initialize(self, argv=None):
        self.parse_command_line(argv)
        if self.config_file:
            self.load_config_file(self.config_file)
        self.load_config_environ()
        if not self.paths:
            self.log.error("No paths specified!")
            sys.exit(1)

    def _initialize_projects(self):
        initialize_projects(self.projid_file)

    def _reconcile_projfiles(self):
        reconcile_projfiles(
            self.paths,
            self.projects_file,
            self.projid_file,
            self.min_projid,
        )

    def _reconcile_quotas(self):
        # Convert GB to KB for xfs_quota
        hard_quota_kb = int(self.hard_quota * 1024 * 1024)
        reconcile_quotas(
            self.projid_file, hard_quota_kb=hard_quota_kb, exclude_dirs=self.exclude
        )

    def start(self):
        self._initialize_projects()

        while True:
            self._reconcile_projfiles()
            self._reconcile_quotas()
            time.sleep(self.wait_time)


def main():
    QuotaManager.launch_instance()


if __name__ == "__main__":
    main()
